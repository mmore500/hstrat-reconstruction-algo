\section{Proposed Algorithm} \label{sec:algorithm}

In this section, we overview the existing naive approach used for constructing prefix tries of hereditary stratigraphy markers, and describe the proposed shortcut-based approach developed in this work.
Notation describes hereditary stratigraphy markers as a pair of two properties: \textit{rank} $r$, referring to the generation at which a marker was generated, and \textit{differentia} $d$, referring to the randomly-generated value distinguishing a given marker from others generated at that generation.

\subsection{Naive Trie-Building Algorithm} \label{sec:algorithm:naive}

The naive algorithm treats each organism's sequence of stored rank-differentia pairs as a string: each differentia $d$ constitutes a character at the rank $r$-th string position.
Differentia values missing due to having been overwritten are considered as wildcard characters.

For two rank-differentia strings, common ancestry corresponds to a shared prefix of string characters, which have been inherited from their most recent common ancestor (MRCA).
Under this framing, phylogenies correspond to a trie --- a tree-like data structure where each node corresponds to a character in a string, and each path from the root to a leaf node reads out a stored string \citep{fredkin1960trie}.

The first step in naive reconstruction is to sort all organisms in ascending order by number of generations elapsed.
Due to each organism using the same algorithm to determine which markers to overwrite, this order guarantees that any data missing from an organism will also have been discarded by all subsequent organisms.

We initialize an empty trie, consisting of a single root node.
Trie building proceeds by processing organisms one at a time in their sorted order.
For each organism, we iterate through rank-differentia pairs in chronological order.
At each rank-differentia pair, we either continue along the existing trie, branch off to create a new path, or --- in a special case --- address missing information (Algorithm~\ref{alg:old}).

\input{alg/old-reconst}

Missing information is recognized as follows.
Suppose we have reached trie node $n$ with rank $r_1$ and must next process rank-differentia pair $(r_2,\; d)$ from current organism $o$.
If any node with rank $r' < r_2$ exists among children of current node $n$, we know that $r'$ must have been deleted from organism $o$ as its record skips directly from $r_1$ to $r_2$.

To maximize reconstruction accuracy in the case of missing data, we must assess which --- if any --- of $n$'s children our missing datum at $r'$ would have likely corresponded to.
Essentially, when reaching missing information, we must infer that information, which we do by looking ahead in the tree.
Specifically, we search forward for the path with the longest successive streak of differentia matching to current organism $o$ \citep{moreno2024analysis}.
If there is no matching path, we simply branch off node $n$ rather than continuing to traverse through its children.

Note that this approach suffers the cost of doing significant extra work to handle missing information.
In the worst case, there could be an exponential number of matching paths to check, owing to the possibility of nested branch-outs at successive wildcard sites.
These searches are repeated for each organism, regardless of whether or not a similar search was already done.
Therefore, we present an improved algorithm that consolidates this extra work into a single step that never needs to be repeated.

\subsection{Proposed Shortcut Algorithm} \label{sec:algorithm:shortcut}

\input{fig/algo-diagram.tex}

We present a modification of Algorithm~\ref{alg:old} where we replace the best path search in line 9 with a more intelligent consolidation step to deal with missing ranks.
The main idea of this algorithm is to realize that, as previously stated, once data from a specific rank is no longer included in one organism, it will not be included in any subsequent organisms, meaning that the nodes in the tree corresponding to that rank are no longer useful.
So, by building shortcuts around any nodes that have become irrelevant, we can speed up the reconstruction process for all future nodes, too.

We detect missing information the same way as in the naive trie algorithm: during iteration, we notice that when a child $c$ of the current node $n$ has a rank $r'$ that is less than the current rank $r$ being processed, we know we do not have information for any rank between $r'$ and $r$ for this organism and any subsequent organism (due to sorting by generational depth).
% The key insight to the way we manage this scenario is that, in the big picture, we only care about this child if some of its descendants at rank $r$ have a differentia value $d$.

Extending this idea, we know that information for any rank between $r'$ and $r$ is meaningless (as they all have been deleted for organism $o$ and any subsequent organisms). 
So, we can bypass every one of $n$'s descendants that have a rank less than $r$, as their information is now meaningless.
We do this by creating shortcut edges from $n$ to the set of descendants whose rank is at least $r$, but whose parent's rank is not.
For example, see Figure~\ref{fig:algo-diagram}, where we detect a dropped rank in (b) and create shortcut edges in (c), around each descendant with that dropped rank.

However, since some descendants of $n$ may have children with equivalent information (like step (d) in Figure~\ref{fig:algo-diagram}), we may end up with shortcuts from $n$ to effectively indistinguishable nodes (with different original parents but the same differentia value).
This situation can be resolved by essentially `merging' the duplicates by choosing one to keep and creating more shortcut edges from the kept one to the children of the removed one (see step (e) in Figure~\ref{fig:algo-diagram}).

Now, adding any organisms that are missing data from the removed level becomes trivial, as the algorithm can use the newly created shortcuts while skipping the missing information that was hidden by the consolidation step.
We no longer need to look down branches from $n$ because the ``wildcard'' value has been eliminated --- each child of $n$ now has a rank greater than or equal to $r$.
% So, there is no longer a concern of missing information when processing $n$ at rank $r$, and these shortcuts are then used to add any subsequent organisms if need be.
If, at some point in the algorithm, $r$ itself becomes a rank of missing information, additional shortcuts are built according to the same procedure.

\input{alg/consolidation.tex}

The key to maintaining accuracy lies in the fact that since we retain original trie structure information (as represented by the gray nodes in Figure~\ref{fig:algo-diagram}), we preserve the full detail and granularity of the naive approach.
After the algorithm is run, we can simply use the original trie edges as the inferred phylogenetic tree.
See Algorithm~\ref{alg:consolidation} to see pseudocode for this algorithm.
Details about algorithm implementation are provided in supplemental material \citep{supplemental}.
